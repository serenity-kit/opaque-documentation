import { PageWrapper } from "../components/blocks/PageWrapper";
import { BlockWrapper } from "../components/blocks/BlockWrapper";
import { Hero } from "../components/blocks/Hero";

<Hero
  header="Opaque"
  children={
    <div>
      <div>
        Secure password based client-server authentication without the server
        ever obtaining knowledge of the password.
        <br />
        <br />
      </div>
      <div>
        A JavaScript implementation of the{" "}
        <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-opaque/">
          OPAQUE protocol
        </a>
        .
      </div>
      <div>
      <h3>Benefits</h3>
      <ul>
        <li>Never accidentally log passwords</li>
        <li>Security against pre-computation attacks upon server compromise</li>
        <li>Foundation for encrypted backups and end-to-end encryption apps</li>
      </ul>
      </div>
    </div>

}
/>

import { Example } from "../components/blocks/Example";
import { InteractiveForm } from "../components/InteractiveForm";

<Example
  header="System Simulation"
  text="Test the protocol and see how it works"
>
  <InteractiveForm />
</Example>

<BlockWrapper>

### Details

OPAQUE provides robust security measures that effectively neutralize various types of attacks. Unlike traditional methods, it eliminates the need to send passwords to the server, thereby thwarting sniffing and replay attacks. Moreover, the protocol prevents pre-computation attacks by attackers.

Through the use of an Oblivious Pseudo-Random Function (OPRF), OPAQUE safeguards the password and basically some form of "salt", making it impervious to direct password leaks. This protocol has also undergone rigorous testing and offers mathematical proofs of security within a robust model.

Another advantage is its ability to offload the memory-hard key-stretching function to the client side. This not only enhances security but also minimizes the server's vulnerability to computational denial-of-service (DoS) attacks.

Furthermore, OPAQUE can function securely over an unencrypted communication channel, removing the necessity for additional layers like TLS. It even includes a countermeasure against user enumeration attacks: the server can return a decoy record, making it impossible for an attacker to determine whether a particular user exists or not.

</BlockWrapper>

<PageWrapper>

## Downsides

- The protocol requires JavaScript to run on the client
- Registration and login require one extra request roundtrip to complete each flow

## Who is using Opaque?

- [Serenity](https://github.com/serenity-kit/serenity) as authentication mechanism for the account

## Who is using the OPAQUE protocol?

- [WhatsApp](https://iacr.org/submit/files/slides/2023/rwc/rwc2023/IT_2/slides.pdf) for their end-to-end encrypted backups

## Security

- [Security Analysis of OPAQUE](https://eprint.iacr.org/2018/163.pdf)
- [Security Audit of opaque-ke](https://research.nccgroup.com/2021/12/13/public-report-whatsapp-opaque-ke-cryptographic-implementation-review/)

## Benefits compared to password hashing

- The server never learns the password and therefor never can log it (accidentally)

## Tradeoffs compared to password hashing

- Requires JavaScript to run on the client
- One extra roundtrip for registration and login

## Benefits compared to Passkeys

- No need for users to rely on an external authority for key storage. Usually Apple, Google or Microsoft.
- No device/browser/OS lock-in. On Linux for example there is no Passkey support.
- No support for a stable `export_key` on the client. This makes Passkeys unsuitable for encrypted backups or as a foundation for end-to-end encryption apps. Might be possible in the future with the [PRF Extension](https://w3c.github.io/webauthn/#prf-extension)

## Tradeoffs compared to Passkeys

- You still need to remember and store a password. Passwordless authentication is preferable.
- Passkeys have even stronger security guarantees against server compromise since only a public key is stored.

Note: You can also deploy Passkeys and have Opaque as a fallback for users without Passkeys. Best of both worlds.

## Relevant building blocks and inspirations

- 2018: The [OPAQUE](https://eprint.iacr.org/2018/163.pdf) paper was published.
- 2018-2023 A group of IETF members worked on the [OPAQUE protocol RFC](https://datatracker.ietf.org/doc/draft-irtf-cfrg-opaque/).
- 2020: Work on [opaque-ke](https://github.com/facebook/opaque-ke) started.
- 2020: Work on [opaque-wasm](https://github.com/marucjmar/opaque-wasm) started. It allowed us to give explore the protocol in a beta and inspired us to build a full library. We made a comparison table between the two libraries [here](/docs/faq#how-does-it-compare-to-opaque-wasm).

</PageWrapper>
