import * as opaque from "@serenity-kit/opaque";

### code testing

Example code to see the different usecases of syntax-highlighting.

```ts
const timeoutDuration = 5000;

export default function apiCall(route, body = {}, method = "POST") {
  const request = new Promise((resolve, reject) => {
    const headers = new Headers({
      "Content-Type": "application/json",
    });

    const requestDetails = {
      method,
      mode: "cors",
      headers,
    };

    if (method !== "GET") requestDetails.body = JSON.stringify(body);

    function handleErrors(response) {
      if (response.ok) {
        return response.json();
      } else {
        throw Error(response.statusText);
      }
    }

    const serverURL =
      process.env.REACT_APP_SERVER_URL || `http://localhost:3000`;

    fetch(`${serverURL}/${route}`, requestDetails)
      .then(handleErrors)
      .then((data) => resolve(data))
      .catch((err) => reject(err));
  });

  const timeout = new Promise((request, reject) => {
    setTimeout(reject, timeoutDuration, `Request timed out!`);
  });

  return new Promise((resolve, reject) => {
    Promise.race([request, timeout])
      .then((result) => resolve(result))
      .catch((error) => reject(error));
  });
}
```

### register

```ts
// 1. user types in email and password
// 2. user clicks "register"
// - password is stored locally
// - email = credentialIdentifier
// 3. clientRegStart is initialized
// 4. client sends request to server
// 5. serverRegStart - server creates response
// 6. server responses to client
// 7. clientFinish initialized creating a registrationUpload
// 8. serverFinish: server uses regUpload to use it as a passwordFile
// in the serverFinish no passwordFile gets generated, the regUpload is the same string as the passwordFile at the end,
// so the server never does anything with the password but already gets the finished passwordFile which is created in such a form
// as that the actual password is not "rückschließbar" from the passwordFile

// TODO explain how the regUpload is created without exposing the password
// try to explain how the algorithm works on a math-base to show why it is not "rückschließbar"
// some functions can be reverted: a + 3 = b, b \* 4 = c => c / 4 - 3 = a
// others (paque) are not
// use metaphors

// add a possibility for the user to go from the graphic or somewhere around it to the explanation of the algorithm
// in the algorithm article (inside the docs) reference deeper reading options (studies, articles, etc)

// represents the secret of the server
// which is a combination of
// - a private key
// - an oprf-seed to initialize the oprf function
// - a fake-private key for failed login attempts
const serverSetup = opaque.serverSetup();

// client
// start of the process on client-side
//
// clientRegistration:
// regRequest to register
//
// the password is only known by the user and stored locally for the process of registration
const { clientRegistration, registrationRequest } =
  opaque.clientRegistrationStart(password);

// server
// start of the process on server-side
//
// credentialIdentifier: username/email
// serverSetup: as described above
// request for registration
const registrationResponse = opaque.serverRegistrationStart({
  serverSetup,
  credentialIdentifier,
  registrationRequest,
});

// client
//
// pw is still stored locally
// credentialIdentifier see above
// response from server
const { registrationUpload } = opaque.clientRegistrationFinish({
  clientRegistration,
  registrationResponse,
  password,
});

// server
// in the serverFinish no passwordFile gets generated, the regUpload is the same string as the passwordFile at the end,
// so the server never does anything with the password but already gets the finished passwordFile which is created in such a form
// as that the actual password is not "rückschließbar" from the passwordFile (explain seperately how)
const passwordFile = opaque.serverRegistrationFinish(registrationUpload);
```
